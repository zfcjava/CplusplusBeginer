//本文编码 为GBK

1.1 抽象的过程

    每种语言都提供了抽象功能。并且复杂问题的解决都与抽象的类型和质量有直接关系。 就如同 汇编对机器做了一部小抽象；而各种语言又是对汇编语言的抽象。但是这种抽象
仍然要求开发人员仍然要按着计算机的机构去思考，而不是实际问题。程序员要做的就是将计算机模式和和现实问题求解模型进行对应。而这种对应不是程序设计语言的“分内之事”。
因而诞生了“程序设计”这个行业。（如果要将机器与实际问题之间的距离比作一个长河，语言设计者实现了上游任务，而下游任务，则交给咱们开发人员了）
    如果程序语言，要直接针对具体实际问题，提供api，那将要么局限在某个特殊领域，要么工作量太大。

    SmallTalk是第一个成功的面向对象语言，是C++的基础语言之一。5个基本特性:

    1) 万物皆对象。对象是一个奇特的变量，它既能存储数据，而且可以对它提出请求，要求它执行自身的运算。理论上，我们可以将要解决的问题中的任何成分抽取成计算机中的
       对象。

    2）程序就是一组对象，对象之间互发消息，通知对方做什么.消息看做是调用摸个对象所属的函数。（这句话没有毛病，函数存在于类中，而对象是属于某类的一个实例）
    3）每一个对象都有一个属于自己的由其他对象组成存储区。这样通过内聚，简化了对象之间的关系。
    4）每个对象都有所属的类（类型）。
    5）一个类的不同实例都能就收相同的消息。

1.2 对象有一个接口。

    疑问：这个接口，是指对象所属的类自己吗？
    答案是肯定的。

1.3 实现的隐藏。

    类的创建者 和 使用者（客户程序员）。在任何关系中，存在边界的概念是其极重要的。

    为什么要有访问控制的概念？
    1）隐私，版权
    2）解耦。只要接口（广义）不变，库程序员可以透明的修改逻辑，不影响客户程序员。

    public private protected

1.4 实现的重用（聚合）

    文章中提到组合、聚合的方式，将一个对象变为另一个类实例的成员变量。

1.5 实现的重用（继承）

1.5.1 is - a 关系和 is like a 关系

    is - a 是一种纯代替 ，并没有 在派生类中增加新的成员

    is - like -a 是在新派生类中增加了新成员

1.6 具有多态性的可互换对象

    当程序员处理类层次结构时，不希望他处理的是特殊类型，而是基本类型 --- 也就是面向接口编程 --- 。这样程序代码就不会都到新类型
的影响，而增加新类型是扩展面向对象程序适应新情况最普通的方法。

    多态得以实现的本质是 晚捆绑，早起面向过程的编译器是 早捆绑的。在代码表现时，为 virtual

1.7 创建和销毁对象

    对象存储在什么位置？生命周期？

    不同的设计语言有不同的规则。c++ 把效率控制作为最重要的问题，所以为程序员提供了一个选择：
    a.为了最大化运行速度，可以将对象放在栈或者静态区内，可以有cpu在执行时直接存放（快速分配和释放）。在栈中的变量成为自
动变量或者局部变量。静态区内存中固定区域，在程序执行前分配。弊端：牺牲了灵活性，需要明确对象的数量、生命周期和类型。
    b.在堆区域动态创建对象，可以不知道对象的数据、类型和生命周期。这些内容都是在程序运行时，动态设置的。创建和释放分别需要
关键字 new delete ;弊端：在堆中创建对象就比较慢了。 (我们更倾向于灵活性)

    生命周期：栈与静态区的对象的生命周期有编译器决定；堆有程序员决定。

1.8 异常处理：应对错误

    从程序设计语言开始，错误处理就是最重要的问题之一。因为设计一个好的错误处理方案，非常困难，许多语言忽略了这个问题，将这个
问题抛给了库设计者，而库的设计者往往采取不彻底的措施，即可以在许多情况起作用，但是很容易被绕开，通常是被忽略掉的。大多数
错误处理方案的一个主要问题：一厢情愿的认为程序员会遵守 一些语言不强制要求而商定好的规范。如果程序员不够小心，则很容易被忘记。

    异常处理 将错误处理直接与程序设计语言甚至操作系统关联起来。 异常是一个对象，它在程序出错的地方被抛出，并且被一段用于处理
特定类型的错误的代码接收。异常处理似乎像是与正常代码一个并行执行，但是必须要被处理。

1.9 分析和设计

    oop在提出之后，形成了一套方法论，在使用方法论之前，首先明确解决什么问题是重要的。

1.9.1

1.9.2





































